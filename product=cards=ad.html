<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/button-back-to.css">
</head>
<body>
<header>
    <a class="button-back-to" href="index.html">
        <svg class="button-back-to__img" fill="#000000" height="14px" width="14px" id="back-arrow"
             viewBox="0 0 219.151 219.151">
            <g>
                <path d="M94.861,156.507c2.929,2.928,7.678,2.927,10.606,0c2.93-2.93,2.93-7.678-0.001-10.608l-28.82-28.819l83.457-0.008
		        c4.142-0.001,7.499-3.358,7.499-7.502c-0.001-4.142-3.358-7.498-7.5-7.498l-83.46,0.008l28.827-28.825
		        c2.929-2.929,2.929-7.679,0-10.607c-1.465-1.464-3.384-2.197-5.304-2.197c-1.919,0-3.838,0.733-5.303,2.196l-41.629,41.628
		        c-1.407,1.406-2.197,3.313-2.197,5.303c0.001,1.99,0.791,3.896,2.198,5.305L94.861,156.507z"/>
            </g>
        </svg>
        к оглавлению</a>
    <h1 class="lesson-topic">работа с DOM</h1>
</header>
<main>
    <h2 class="program-name">карточки товара и манипуляции с ними</h2>

    <h3 class="example__title">Свойство children, дочерние элементы</h3>
    <div class="example">
        <section class="example__description">
            <p class="example__paragraph">
                Раньше мы получали данные о состояниях товара, в этот раз из выгрузки программы 1-Кекс будет приходить
                полная информация. Данные будут содержать название продукта, его цену, изображение, доступность для
                заказа и прочую информацию. Поэтому для решения задачи нам не нужен верстальщик, ведь все данные будут у
                нас. Мы сами добавим элементы в разметку с помощью скриптов.

                Правда, программа 1-Кекс пока барахлит и не хочет отдавать выгрузку. Поэтому сначала, чтобы не терять
                время, мы создадим одну карточку с нуля. Верстальщик показал нам, как должны быть свёрстаны карточки
                товаров, поэтому сейчас в разметке они уже есть. Мы будем ориентироваться на эти карточки, создавая
                свою, а затем удалим и добавим все карточки самостоятельно.

                Как обычно, будем решать задачу постепенно: создадим элемент, наполним его необходимым контентом и
                добавим подходящие классы.

                Чтобы карточка оказалась в разметке, нужно найти родительский элемент, в который мы будем эту карточку
                добавлять. В нашем случае это список products. Именно в нём хранятся карточки товаров, и три из них уже
                есть в разметке. Мы можем найти их не только через querySelectorAll, но и с помощью свойства children
                списка products.

                Обращение к свойству выглядит так: DOM-элемент.children. Это свойство возвращает коллекцию дочерних, то
                есть вложенных, DOM-элементов. В случае с нашим списком коллекция должна состоять из трёх элементов — по
                одному на каждый элемент списка li.

                Перед добавлением новой карточки найдём список products и выведем в консоль список его дочерних
                элементов с помощью children. Убедимся, что длина коллекции равна количеству вложенных элементов, а уже
                затем начнём добавлять новую карточку.

            </p>
        </section>
        <section class="example__solution">
            <code class="example__code">
                var cardList = document.querySelector('.products');
                console.log(cardList.children);

            </code>
        </section>
    </div>
    <section class="terminal">
        <h4 class="terminal__window">terminal</h4>
        <p class="terminal__result">[li.product.product--available, li.product.product--unavailable,
            li.product.product--available] (HTMLCollection)
            <li class="product product--available"> (HTMLLIElement)
        <h2 class="product__title">Селфи-палка для начинающих
            <img class="product__image" src="device/item-1.jpg" alt="Селфи-палка для начинающих"/>
            <p class="product__price">200


                </li>
                <li class="product product--unavailable"> (HTMLLIElement)
            <h2 class="product__title">Профессиональная селфи-палка
                <img class="product__image" src="device/item-2.jpg" alt="Профессиональная селфи-палка"/>
                <p class="product__price">1500


                    </li>
                    <li class="product product--available"> (HTMLLIElement)
                <h2 class="product__title">Непотопляемая селфи-палка
                    <img class="product__image" src="device/item-3.jpg" alt="Непотопляемая селфи-палка"/>
                    <p class="product__price">2500
                    </p>
    </section>

    <h3 class="example__title">Метод createElement, создание элемента</h3>
    <div class="example">
        <section class="example__description">
            <p class="example__paragraph">
                Приступим к добавлению карточки товара. Если бы мы добавляли новый элемент через разметку, то мы бы
                добавили ещё один li с классом product в список товаров. В JavaScript для выполнения этой же задачи
                нужно сделать несколько шагов. Пойдём по порядку.

                Создание DOM-элемента

                Для начала нужно создать новый элемент списка, li. Создавать элементы можно разными способами, мы будем
                использовать метод createElement() объекта document. Метод принимает на вход строку с именем тега и
                возвращает созданный DOM-элемент. Этот элемент можно записать в переменную для дальнейших манипуляций:

                var card = document.createElement('li');

                Обратите внимание, что createElement — метод именно объекта document. То есть с его помощью мы создаём
                какой-то элемент для этого документа, пока не указывая, где он будет находиться в DOM.

                Добавление класса

                С этим шагом вы уже знакомы. Работаем с classList созданного элемента:

                var card = document.createElement('li');
                card.classList.add('card');

                Добавление в DOM-дерево

                Вновь созданный элемент по умолчанию не находится в DOM-дереве и не отображается на странице. Мы просто
                храним его где-то в переменной. Чтобы новый элемент появился на странице, его нужно добавить в DOM. Для
                этого найдём в текущем DOM-дереве элемент (родитель) и вставим в него наш элемент.

                Мы будем использовать метод appendChild() родителя. Этот метод принимает на вход элемент и вставляет его
                в конец родительского элемента. То есть, если в списке уже есть три элемента, как в нашем случае,
                добавленный с помощью appendChild элемент станет четвёртым в списке.

                var list = document.querySelector('.cards');
                var card = document.createElement('li');
                card.classList.add('card');

                // После вызова этого метода новый элемент отрисуется на странице
                list.appendChild(card);

                Вот что произойдёт с разметкой после вызова appendChild:

                <!-- Исходное состояние разметки -->
            <ul class="cards">
                <li class="card">Существующий элемент</li>
            </ul>

            <!-- Состояние после вызова appendChild -->
            <ul class="cards">
                <li class="card">Существующий элемент</li>
                <li class="card">Добавленный элемент</li>
            </ul>

            Последовательность добавления элемента в DOM может быть другой: можно создать элемент с помощью
            createElement и сразу вставить его в родительский элемент, а уже затем добавлять классы. Но это не лучший
            путь — каждое изменение в DOM вызывает перерисовку страницы, а это дорогая операция, она занимает много
            времени.
            </p>
        </section>
        <section class="example__solution">
            <code class="example__code">
                var cardList = document.querySelector('.products');
                console.log(cardList.children);

                var listItem = document.createElement('li');
                listItem.classList.add('product');
                cardList.appendChild(listItem);
                console.log(cardList.children);

            </code>
        </section>
    </div>
    <section class="terminal">
        <h4 class="terminal__window">terminal</h4>
        <p class="terminal__result">

            [li.product.product--available, li.product.product--unavailable, li.product.product--available]
            (HTMLCollection)
            [li.product.product--available, li.product.product--unavailable, li.product.product--available, li.product]
            (HTMLCollection)
            <li class="product product--available">… (HTMLLIElement)
            <li class="product product--unavailable">… (HTMLLIElement)
            <li class="product product--available">… (HTMLLIElement)
        <li class="product"> (HTMLLIElement)
        </p>
    </section>

    <h3 class="example__title">Свойство textContent, текстовое содержимое</h3>
    <div class="example">
        <section class="example__description">
            <p class="example__paragraph">
                Карточка уже в разметке, но пока она пустая. Начнём наполнять её контентом. В первую очередь добавим
                название товара и его цену.

                Алгоритм почти такой же, как и при добавлении самой карточки: создание элемента, добавление класса,
                вставка текстового содержимого (название товара, его цена), добавление элемента в конец карточки. Все
                шаги нам знакомы, кроме добавления текста. Как это сделать?

                У каждого DOM-элемента есть свойство textContent. Оно содержит текстовое содержимое элемента. В
                textContent не попадает разметка, только текст.

                // HTML
            <p>Я — <em>текстовый элемент</em>.</p>

            // JS
            var p = document.querySelector('p');
            console.log(p.textContent);
            // Выведет: Я — текстовый элемент.

            Это свойство объекта, которое можно не только прочитать, но и записать или перезаписать. Поэтому, если мы
            хотим задать элементу текстовое содержимое, достаточно записать в свойство необходимое значение.

            p.textContent = 'Теперь у меня новое содержимое.';
            console.log(p.textContent);
            // Выведет: Теперь у меня новое содержимое.

            // В HTML содержание тега изменится
            <p>Теперь у меня новое содержимое.</p>

            Добавим в карточку название товара и его цену. Убедимся, что все новые элементы отображаются на странице.

            JavaScript
            100%
            Консоль
            ЗадачиВыполнено 0 из 5

            </p>
        </section>
        <section class="example__solution">
            <code class="example__code">
                var cardList = document.querySelector('.products');
                console.log(cardList.children);

                var listItem = document.createElement('li');
                listItem.classList.add('product');
                cardList.appendChild(listItem);
                console.log(cardList.children);

                var title = document.createElement('h2');
                title.classList.add('product__title');
                title.textContent = 'Профессиональная селфи-палка';
                listItem.appendChild(title);

                var price = document.createElement('p');
                price.classList.add('product__price');
                price.textContent = '1000';
                listItem.appendChild(price);

            </code>
        </section>
    </div>
    <section class="terminal">
        <h4 class="terminal__window">terminal</h4>
        <p class="terminal__result">
        </p>
    </section>

    <h3 class="example__title">Функция для создания элементов</h3>
    <div class="example">
        <section class="example__description">
            <p class="example__paragraph">
                Обратите внимание, по мере выполнения задачи, мы всё чаще повторяем одни и те же операции: создаём
                элементы с помощью document.createElement(), добавляем им классы через элемент.classList.add(), а в
                некоторых случаях и текстовое содержимое с помощью элемент.textContent. Пора вынести повторяющийся код в
                функцию, чтобы не писать каждый раз много похожих строчек кода.

                Объявим функцию, которая будет принимать на вход три строки: имя тега (tagName), имя класса (className)
                и текстовое содержимое (text) элемента. Внутри неё будем создавать элемент с классом и текстом, а затем
                возвращать его наружу.

                Не у всех элементов есть текстовое содержимое, поэтому дадим возможность вызывать функцию не с тремя, а
                с двумя параметрами. JavaScript сам по себе это позволяет. Но нам нужно предусмотреть проверку на
                присутствие третьего параметра. Будем добавлять в элемент текст с помощью textContent только если
                параметр text существует.

                Как проверить наличие параметра? Если параметр не был передан в функцию, его значение внутри функции
                будет равно undefined, то есть не определено. Значение undefined приводится к логическому значению
                false, поэтому достаточно такой простейшей проверки:

                var createCard = function (required, optional) {
                if (optional) {
                // действия с optional
                }
                }

                // Функция отработает, но действия с optional выполняться не будут
                createCard('Обязательный аргумент');

                // Функция отработает и действия с optional выполнятся
                createCard('Обязательный аргумент', 'Необязательный аргумент');

                А что будет если аргумент передан? Во-первых, он не будет равен undefined. Во-вторых, внутри оператора
                «круглые скобки» программа получит значение этого параметра и приведёт его к логическому типу. Как вы
                знаете из части «Условия», строки могут сами выступать в роли условий. Пустая строка приводится в false,
                а непустая к true. То есть, элементу добавится текстовое содержимое только тогда, когда мы передадим
                последним аргументом непустую строку. То, что надо.
            </p>
        </section>
        <section class="example__solution">
            <code class="example__code">
                var makeElement = function (tagName, className, text) {
                var element = document.createElement(tagName);
                element.classList.add(className);
                if (text) {
                element.textContent = text;
                }
                return element;
                };

                var cardList = document.querySelector('.products');
                console.log(cardList.children);

                var listItem = document.createElement('li');
                listItem.classList.add('product');
                cardList.appendChild(listItem);
                console.log(cardList.children);

                var title = document.createElement('h2');
                title.classList.add('product__title');
                title.textContent = 'Профессиональная селфи-палка';
                listItem.appendChild(title);

                var price = document.createElement('p');
                price.classList.add('product__price');
                price.textContent = '1000';
                listItem.appendChild(price);

            </code>
        </section>
    </div>
    <section class="terminal">
        <h4 class="terminal__window">terminal</h4>
        <p class="terminal__result">
        </p>
    </section>

    <h3 class="example__title">Оптимизируем код</h3>
    <div class="example">
        <section class="example__description">
            <p class="example__paragraph">
                Теперь, когда у нас есть специальная функция, мы можем заменить для каждого элемента строки с созданием,
                добавлением класса и текстового содержимого на одну строку с вызовом makeElement. Так мы сделаем код
                более читаемым и удобным.

                Обратите внимание, что создавая карточку товара с помощью makeElement, мы передаём в функцию только тег
                li и класс product. Текстового содержимого у самой карточки нет, оно есть только у её дочерних элементов
                (названия продукта и цены). Вот и случай, для которого мы писали проверку в функции!
            </p>
        </section>
        <section class="example__solution">
            <code class="example__code">
                var makeElement = function (tagName, className, text) {
                var element = document.createElement(tagName);
                element.classList.add(className);
                if (text) {
                element.textContent = text;
                }
                return element;
                };

                var cardList = document.querySelector('.products');
                console.log(cardList.children);

                var listItem = makeElement('li', 'product');
                cardList.appendChild(listItem);
                console.log(cardList.children);

                var title = makeElement('h2', 'product__title', 'Профессиональная селфи-палка');
                listItem.appendChild(title);

                var price = makeElement('p', 'product__price', '1000');
                listItem.appendChild(price);

            </code>
        </section>
    </div>
    <section class="terminal">
        <h4 class="terminal__window">terminal</h4>
        <p class="terminal__result">
        </p>
    </section>

    <h3 class="example__title">Свойство src, адрес изображения</h3>
    <div class="example">
        <section class="example__description">
            <p class="example__paragraph">
                Нашей карточке не хватает изображения товара. Создадим его с помощью makeElement, передав функции имя
                тега 'img' и класс 'product__image'. Третий параметр мы не передаём, потому что у изображения нет
                текстового содержимого.

                Чтобы картинка отобразилась на странице, нужно задать ей адрес файла с изображением, то есть значение
                атрибута src. Значением этого атрибута можно управлять с помощью одноимённого свойства DOM-элемента:

                var picture = document.createElement('img');
                picture.src = 'images/picture.jpg'

                Таким же образом добавим изображению альтернативный текст, то есть описание фотографии. Если фотография
                не загрузится, на странице отобразится этот текст, чтобы пользователь понимал, что за блок находится
                перед ним. Кроме того, такой текст распознают программы, читающие вслух содержимое экрана (скринридеры),
                поэтому, добавляя такое описание, мы простым способом делаем элемент интерфейса доступным. Добавляем
                альтернативный текст через свойство alt. Как видите, названия атрибутов тегов и свойств DOM-элементов
                часто (но не всегда) совпадают.

                picture.alt = 'Непотопляемая селфи-палка';

                После создания изображения и «настройки» его свойств, добавим изображение в карточку. Обратите внимание,
                фотографию мы должны добавить перед ценой товара, потому что в разметке порядок тегов именно такой.
                Поэтому и код создания картинки нужно добавить перед кодом создания цены.
            </p>
        </section>
        <section class="example__solution">
            <code class="example__code">
                var makeElement = function (tagName, className, text) {
                var element = document.createElement(tagName);
                element.classList.add(className);
                if (text) {
                element.textContent = text;
                }
                return element;
                };

                var cardList = document.querySelector('.products');
                console.log(cardList.children);

                var listItem = makeElement('li', 'product');
                cardList.appendChild(listItem);
                console.log(cardList.children);

                var title = makeElement('h2', 'product__title', 'Профессиональная селфи-палка');
                listItem.appendChild(title);

                // Изображение добавляйте сюда
                var picture = makeElement('img', 'product__image');
                picture.src = 'device/item-4.jpg';
                picture.alt = 'Профессиональная селфи-палка';
                listItem.appendChild(picture);

                var price = makeElement('p', 'product__price', '1000');
                listItem.appendChild(price);

            </code>
        </section>
    </div>
    <section class="terminal">
        <h4 class="terminal__window">terminal</h4>
        <p class="terminal__result">
        </p>
    </section>


    <h3 class="example__title">Функция для создания карточки товара</h3>
    <div class="example">
        <section class="example__description">
            <p class="example__paragraph">
                Одну карточку мы добавили, но теперь Кекс просит добавить разом много карточек, основываясь на
                полученных данных. Данных пока нет, система барахлит, но мы не будем сидеть без дела и подготовим всё
                для решения задачи.

                Алгоритм добавления одной карточки не сильно отличается от добавления десяти или двадцати карточек. Мы
                точно так же создаём элементы, добавляем им классы, атрибуты и текстовое содержимое, только много раз.
                Конечно, без функции тут не обойтись.

                Объявим функцию createCard, которая будет отвечать за создание карточки товара. Внутри функции будет
                создаваться элемент списка, а затем будут создаваться и «упаковываться» в него другие части карточки:
                заголовок, картинка товара и стоимость. Возвращать функция будет готовый DOM-элемент. Снаружи функции мы
                оставим поиск самого списка товаров и вставку в него DOM-элементов, возвращённых из функции.

                Такое «разделение труда» сделает наш код более универсальным. Функция createCard «не знает» ничего о
                том, куда именно вставлять DOM-элемент товара, поэтому её можно повторно использовать где угодно без
                каких-либо правок. Например, можно вставлять созданные в функции карточки товаров в список
                спецпредложений или в совершенно другой список новинок.

                Мы постепенно переходим от кустарного производства к конвейерному. Так и должно быть — готовая
                программа, которая стабильно и корректно работает с любым количеством элементов.

                JavaScript
                100%
                Консоль
                ЗадачиВыполнено 0 из 4

            </p>
        </section>
        <section class="example__solution">
            <code class="example__code">
                var makeElement = function (tagName, className, text) {
                var element = document.createElement(tagName);
                element.classList.add(className);
                if (text) {
                element.textContent = text;
                }
                return element;
                };

                var createCard = function () {
                var listItem = makeElement('li', 'product');

                var title = makeElement('h2', 'product__title', 'Профессиональная селфи-палка');
                listItem.appendChild(title);

                var picture = makeElement('img', 'product__image');
                picture.src = 'device/item-4.jpg';
                picture.alt = 'Профессиональная селфи-палка';
                listItem.appendChild(picture);

                var price = makeElement('p', 'product__price', '1000');
                listItem.appendChild(price);

                return listItem;
                };

                var cardList = document.querySelector('.products');
                console.log(cardList.children);


            </code>
        </section>
    </div>
    <section class="terminal">
        <h4 class="terminal__window">terminal</h4>
        <p class="terminal__result">
        </p>
    </section>

    <h3 class="example__title">Проверяем работу функции для создания карточки</h3>
    <div class="example">
        <section class="example__description">
            <p class="example__paragraph">
                Разметка первых трёх товаров была нужна только в качестве подсказки. Мы подглядывали в неё, когда
                собирали свою карточку с помощью JavaScript.

                Сейчас, когда функция для создания карточки товара написана, пришло время избавиться от исходной
                разметки. В HTML-коде должен остаться пустой тег ul.

                Смело удаляйте все элементы списка из разметки, потом вызовите функцию createCard и добавьте результат
                работы этой функции в DOM. Так мы проверим, что функция работает корректно.
            </p>
        </section>
        <section class="example__solution">
            <code class="example__code">
                var makeElement = function (tagName, className, text) {
                var element = document.createElement(tagName);
                element.classList.add(className);
                if (text) {
                element.textContent = text;
                }
                return element;
                };

                var createCard = function () {
                var listItem = makeElement('li', 'product');

                var title = makeElement('h2', 'product__title', 'Профессиональная селфи-палка');
                listItem.appendChild(title);

                var picture = makeElement('img', 'product__image');
                picture.src = 'device/item-4.jpg';
                picture.alt = 'Профессиональная селфи-палка';
                listItem.appendChild(picture);

                var price = makeElement('p', 'product__price', '1000');
                listItem.appendChild(price);

                return listItem;
                };

                var cardList = document.querySelector('.products');
                var cardItem = createCard();
                cardList.appendChild(cardItem);

            </code>
        </section>
    </div>
    <section class="terminal">
        <h4 class="terminal__window">terminal</h4>
        <p class="terminal__result">
        </p>
    </section>

    <h3 class="example__title"></h3>
    <div class="example">
        <section class="example__description">
            <p class="example__paragraph">
            </p>
        </section>
        <section class="example__solution">
            <code class="example__code">

            </code>
        </section>
    </div>
    <section class="terminal">
        <h4 class="terminal__window">terminal</h4>
        <p class="terminal__result">
        </p>
    </section>


    <h3 class="example__title">Живые данные</h3>
    <div class="example">
        <section class="example__description">
            <p class="example__paragraph">
                HTML Academy
                Предыдущее задание
                JavaScript в браузере
                18/23
                Вернуться в список заданий

                1. Скрипт на старт!
                2. Метод querySelector, поиск элемента
                3. Метод classList.add, добавление класса
                4. Метод querySelectorAll, поиск нескольких элементов
                5. Перебор коллекции элементов
                6. Проверяем свойство isAvailable
                7. Проверяем свойство isSpecial
                8. Конспект «JS в браузере». Раздел 1
                9. Двенадцатая программа: «Испытание мороженым»
                10. Свойство children, дочерние элементы
                11. Метод createElement, создание элемента
                12. Свойство textContent, текстовое содержимое
                13. Функция для создания элементов
                14. Оптимизируем код
                15. Свойство src, адрес изображения
                16. Функция для создания карточки товара
                17. Проверяем работу функции для создания карточки
                18. Живые данные
                19. Проверяем доступность товара
                20. Спецпредложение
                21. Используем массив объектов
                22. Конспект «JS в браузере». Раздел 2
                23. Тринадцатая программа: «Мороженое. Возвращение»

                Следующее задание

                Кирилл ГрантКирилл Грант

                Живые данные

                Наконец-то Кекс прислал пример выгрузки с данными для одного товара. Негусто, но этого достаточно, чтобы
                доработать функцию createCard. Ведь сейчас все данные в ней статичные, то есть одинаковые, и сколько бы
                раз мы её ни вызвали, карточки будут похожими друг на друга как близнецы.

                Информация о товаре представляет собой объект, каждое свойство которого описывает характеристику товара.
                Вначале поработаем с этими свойствами:

                imgUrl — адрес изображения;
                text — название товара;
                price — цена.

                Чтобы функция возвращала разные данные на выходе, нужно, чтобы она получала разные данные на входе.
                Поэтому сначала добавим в функцию createCard параметр product и будем передавать в неё при вызове
                полученный объект с данными (он, кстати, уже вставлен в код, но закомментирован).

                Затем внутри функции нужно заменить фиксированные значения на свойства входного параметра. Например:

                // Было:
                var title = createElement('h2', 'product__title', 'Профессиональная селфи-палка');
                picture.alt = 'Профессиональная селфи-палка';

                // Стало:
                var title = createElement('h2', 'product__title', product.text);
                picture.alt = product.text;

            </p>
        </section>
        <section class="example__solution">
            <code class="example__code">
                var makeElement = function (tagName, className, text) {
                var element = document.createElement(tagName);
                element.classList.add(className);
                if (text) {
                element.textContent = text;
                }
                return element;
                };

                var createCard = function (product) {
                var listItem = makeElement('li', 'product');

                var title = makeElement('h2', 'product__title', product.text);
                listItem.appendChild(title);

                var picture = makeElement('img', 'product__image');
                picture.src = product.imgUrl;
                picture.alt = product.text;
                listItem.appendChild(picture);

                var price = makeElement('p', 'product__price', product.price);
                listItem.appendChild(price);

                return listItem;
                };

                var cardList = document.querySelector('.products');

                var productInfo = {
                isAvailable: true,
                imgUrl: 'device/item-1.jpg',
                text: 'Селфи-палка для начинающих',
                price: 200,
                isSpecial: false,
                specialPrice: null
                };

                var cardItem = createCard(productInfo);
                cardList.appendChild(cardItem);

            </code>
        </section>
    </div>
    <section class="terminal">
        <h4 class="terminal__window">terminal</h4>
        <p class="terminal__result">
        </p>
    </section>

    <h3 class="example__title">Проверяем доступность товара</h3>
    <div class="example">
        <section class="example__description">
            <p class="example__paragraph">
                Три свойства из выгрузки мы уже обрабатываем. На очереди четвёртое: isAvailable. Это свойство хранит
                булево значение, которое описывает наличие товара. Если товар есть, то свойство содержит true, иначе
                false.

                В зависимости от наличия или отсутствия товара карточка должна иметь один из двух дополнительных
                классов: product--available или product--unavailable.

                Эту задачу вы уже решали, поэтому нужно повторить её по аналогии с первой программой. Вот краткий
                пересказ событий:

                заводим переменную для хранения имени класса и записываем в неё значение по умолчанию;
                делаем проверку на наличие товара;
                если проверка не проходит, значение в переменной меняем;
                после проверки добавляем карточке товара класс из переменной.

                После доработки функции нужно её протестировать. Для этого измените в объекте с данными значение
                свойства isAvailable на false. Если всё сделано правильно, то внешний вид карточки изменится.
            </p>
        </section>
        <section class="example__solution">
            <code class="example__code">
                var makeElement = function (tagName, className, text) {
                var element = document.createElement(tagName);
                element.classList.add(className);
                if (text) {
                element.textContent = text;
                }
                return element;
                };

                var createCard = function (product) {
                var listItem = makeElement('li', 'product');

                var title = makeElement('h2', 'product__title', product.text);
                listItem.appendChild(title);

                var picture = makeElement('img', 'product__image');
                picture.src = product.imgUrl;
                picture.alt = product.text;
                listItem.appendChild(picture);

                var price = makeElement('p', 'product__price', product.price);
                listItem.appendChild(price);


                var availabilityClass = 'product--available';
                if (!product.isAvailable) {
                availabilityClass = 'product--unavailable';
                }
                listItem.classList.add(availabilityClass);
                return listItem;
                };

                var cardList = document.querySelector('.products');

                var productInfo = {
                isAvailable: false,
                imgUrl: 'device/item-1.jpg',
                text: 'Селфи-палка для начинающих',
                price: 200,
                isSpecial: false,
                specialPrice: null
                };

                var cardItem = createCard(productInfo);
                cardList.appendChild(cardItem);

            </code>
        </section>
    </div>
    <section class="terminal">
        <h4 class="terminal__window">terminal</h4>
        <p class="terminal__result">
        </p>
    </section>


    <h3 class="example__title">Спецпредложение</h3>
    <div class="example">
        <section class="example__description">
            <p class="example__paragraph">
                Осталось обработать последние два свойства из выгрузки: isSpecial и specialPrice. Свойство isSpecial
                содержит true, если на товар действует спецпредложение. У товара-спецпредложения появляется новая цена,
                которая хранится в specialPrice.

                Похожую задачу вы тоже решали: у карточек спецпредложений должен появляться дополнительный класс
                product--special. Но сейчас нужно ещё и специальную цену показывать. Она должна находиться в абзаце с
                классом product__special-price. Этот абзац должен быть последним дочерним элементом в карточке.

                Порядок действий такой:

                проверяем, является ли товар спецпредложением;
                если проверка проходит, добавляем карточке товара класс,
                а также добавляем внутрь карточки ещё один абзац с соответствующим классом и текстом из свойства
                specialPrice.

                После доработки снова тестируем функцию. Измените в объекте с данными значения свойств isSpecial на true
                и specialPrice на 300 (значение null обозначает «ничего» или, ближе к нашим реалиям, «спеццены нет»).
                Если всё сделано правильно, то внешний вид карточки изменится.

                Почему цена изменилась с 200 на 300? Потому что так искусный маркетолог Кекс понимает спецпредложение.
            </p>
        </section>
        <section class="example__solution">
            <code class="example__code">
                var makeElement = function (tagName, className, text) {
                var element = document.createElement(tagName);
                element.classList.add(className);
                if (text) {
                element.textContent = text;
                }
                return element;
                };

                var createCard = function (product) {
                var listItem = makeElement('li', 'product');

                var title = makeElement('h2', 'product__title', product.text);
                listItem.appendChild(title);

                var picture = makeElement('img', 'product__image');
                picture.src = product.imgUrl;
                picture.alt = product.text;
                listItem.appendChild(picture);

                var price = makeElement('p', 'product__price', product.price);
                listItem.appendChild(price);

                var availabilityClass = 'product--available';
                if (!product.isAvailable) {
                availabilityClass = 'product--unavailable';
                }
                listItem.classList.add(availabilityClass);


                if (product.isSpecial) {
                listItem.classList.add('product--special');
                var specialPrice = makeElement('p', 'product__special-price', product.specialPrice);
                listItem.appendChild(specialPrice);
                }
                return listItem;
                };

                var cardList = document.querySelector('.products');

                var productInfo = {
                isAvailable: true,
                imgUrl: 'device/item-1.jpg',
                text: 'Селфи-палка для начинающих',
                price: 200,
                isSpecial: true,
                specialPrice: 300
                };

                var cardItem = createCard(productInfo);
                cardList.appendChild(cardItem);

            </code>
        </section>
    </div>
    <section class="terminal">
        <h4 class="terminal__window">terminal</h4>
        <p class="terminal__result">
        </p>
    </section>

    <h3 class="example__title"></h3>
    <div class="example">
        <section class="example__description">
            <p class="example__paragraph">
            </p>
        </section>
        <section class="example__solution">
            <code class="example__code">

            </code>
        </section>
    </div>
    <section class="terminal">
        <h4 class="terminal__window">terminal</h4>
        <p class="terminal__result">
        </p>
    </section>

    <h3 class="example__title">Используем массив объектов</h3>
    <div class="example">
        <section class="example__description">
            <p class="example__paragraph">
                Пока мы писали код, пришла полная выгрузка из 1-Кекс. Данные хранятся в массиве объектов cardsData.

                Теперь товаров много и нам нужно вызывать createCard для каждого из них. Кажется, пришло время
                использовать цикл for.

                Напишем цикл, который будет перебирать массив данных. Внутри цикла будем передавать текущий элемент
                массив[i] в функцию createCard и вставлять полученный результат в конец списка товаров. Так мы сделаем
                программу универсальной для любого количества карточек.

                Примерно так может выглядеть цикл:

                var item;

                for (var i = 0; i < array.length; i++) {
                item = createCard(array[i]);
                list.appendChild(item);
                }

                В этом коде мы сначала объявляем переменную, а затем внутри цикла переопределяем её значение на каждой
                итерации. При этом переменную мы используем только внутри цикла. До и после цикла она нам не нужна,
                поэтому объявлять её снаружи цикла бессмысленно. Учтём это и будем создавать переменную внутри цикла на
                каждой итерации. В неё будем записывать результат вызова createCard(массив[i]), а затем добавим
                содержимое этой переменной в конец каталога товаров. Цикл будет выглядеть так:

                for (var i = 0; i < array.length; i++) {
                var item = createCard(array[i]);
                list.appendChild(item);
                }

            </p>
        </section>
        <section class="example__solution">
            <code class="example__code">
                var cardsData = [
                {
                isAvailable: true,
                imgUrl: 'device/item-1.jpg',
                text: 'Селфи-палка для начинающих',
                price: 200,
                isSpecial: false
                },
                {
                isAvailable: false,
                imgUrl: 'device/item-2.jpg',
                text: 'Профессиональная селфи-палка',
                price: 1500,
                isSpecial: false
                },
                {
                isAvailable: true,
                imgUrl: 'device/item-3.jpg',
                text: 'Непотопляемая селфи-палка',
                price: 2500,
                isSpecial: false
                },
                {
                isAvailable: true,
                imgUrl: 'device/item-4.jpg',
                text: 'Селфи-палка «Следуй за мной»',
                price: 4900,
                isSpecial: true,
                specialPrice: 100
                }
                ];

                var makeElement = function (tagName, className, text) {
                var element = document.createElement(tagName);
                element.classList.add(className);
                if (text) {
                element.textContent = text;
                }
                return element;
                };

                var createCard = function (product) {
                var listItem = makeElement('li', 'product');

                var title = makeElement('h2', 'product__title', product.text);
                listItem.appendChild(title);

                var picture = makeElement('img', 'product__image');
                picture.src = product.imgUrl;
                picture.alt = product.text;
                listItem.appendChild(picture);

                var price = makeElement('p', 'product__price', product.price);
                listItem.appendChild(price);

                var availabilityClass = 'product--available';
                if (!product.isAvailable) {
                availabilityClass = 'product--unavailable';
                }
                listItem.classList.add(availabilityClass);

                if (product.isSpecial) {
                listItem.classList.add('product--special');
                var specialPrice = makeElement('p', 'product__special-price', product.specialPrice);
                listItem.appendChild(specialPrice);
                }

                return listItem;
                };

                var cardList = document.querySelector('.products');

                for (var i = 0; i < cardsData.length; i++) {
                var cardItem = createCard(cardsData[i]);
                cardList.appendChild(cardItem);
                }


            </code>
        </section>
    </div>
    <section class="terminal">
        <h4 class="terminal__window">terminal</h4>
        <p class="terminal__result">
        </p>
    </section>

    <h3 class="example__title"></h3>
    <div class="example">
        <section class="example__description">
            <p class="example__paragraph">
            </p>
        </section>
        <section class="example__solution">
            <code class="example__code">

            </code>
        </section>
    </div>
    <section class="terminal">
        <h4 class="terminal__window">terminal</h4>
        <p class="terminal__result">
        </p>
    </section>

</main>
<footer>
    <div class="pagination">
        <a class="pagination__btn pagination__btn--previous">
            <svg class="prev-btn" fill="#000000" height="14px" width="14px" id="back-arrow"
                 viewBox="0 0 219.151 219.151">
                <g>
                    <path d="M94.861,156.507c2.929,2.928,7.678,2.927,10.606,0c2.93-2.93,2.93-7.678-0.001-10.608l-28.82-28.819l83.457-0.008
		        c4.142-0.001,7.499-3.358,7.499-7.502c-0.001-4.142-3.358-7.498-7.5-7.498l-83.46,0.008l28.827-28.825
		        c2.929-2.929,2.929-7.679,0-10.607c-1.465-1.464-3.384-2.197-5.304-2.197c-1.919,0-3.838,0.733-5.303,2.196l-41.629,41.628
		        c-1.407,1.406-2.197,3.313-2.197,5.303c0.001,1.99,0.791,3.896,2.198,5.305L94.861,156.507z"/>
                </g>
            </svg>
            предыдущая</a>
        <a class="pagination__btn pagination__btn--next">следующая
            <svg class="next-btn" fill="#000000" height="14px" width="14px" id="back-arrow"
                 viewBox="0 0 219.151 219.151">
                <g>
                    <path d="M94.861,156.507c2.929,2.928,7.678,2.927,10.606,0c2.93-2.93,2.93-7.678-0.001-10.608l-28.82-28.819l83.457-0.008
		        c4.142-0.001,7.499-3.358,7.499-7.502c-0.001-4.142-3.358-7.498-7.5-7.498l-83.46,0.008l28.827-28.825
		        c2.929-2.929,2.929-7.679,0-10.607c-1.465-1.464-3.384-2.197-5.304-2.197c-1.919,0-3.838,0.733-5.303,2.196l-41.629,41.628
		        c-1.407,1.406-2.197,3.313-2.197,5.303c0.001,1.99,0.791,3.896,2.198,5.305L94.861,156.507z"/>
                </g>
            </svg>
        </a>
    </div>
</footer>
<script src="js-test/rabota-s-DOM-kartochki-tovara.js"></script>
</body>
</html>
